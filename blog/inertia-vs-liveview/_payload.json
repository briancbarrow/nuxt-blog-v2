[{"data":1,"prerenderedAt":205},["ShallowReactive",2],{"/blog/inertia-vs-liveview":3},{"id":4,"title":5,"body":6,"date":194,"description":195,"extension":196,"img":197,"meta":198,"navigation":139,"path":200,"published":139,"seo":201,"stem":202,"tags":203,"__hash__":204},"blog/blog/inertia-vs-liveview.md","Phoenix with Inertia.js vs LiveView",{"type":7,"value":8,"toc":188},"minimal",[9,27,30,35,38,41,45,60,63,66,74,89,93,108,111,164,171,175,178,181,184],[10,11,12,13,20,21,26],"p",{},"I've been messing around with Elixir and Phoenix for a little bit now, and being\na web developer I have definitely played with LiveView. Overall my experience\nhas been positive. A while back I did see this post on Bluesky from\n",[14,15,19],"a",{"href":16,"rel":17},"https://bsky.app/profile/bcardarella.bsky.social/post/3lkv6sioelc2x",[18],"nofollow","Brian Cardarella","\nhighlighting ",[14,22,25],{"href":23,"rel":24},"https://dnlytras.com/blog/on-liveview",[18],"Dimitrios's blog post","\nabout their experience with LiveView.",[10,28,29],{},"I thought it was a really interesting read, and it was nice to see a new\nperspective on LiveView. I personally haven't had too many issues with it, and\nwhen I did I was typically able to find a decent enough solution using another\ntool like Alpine.js. I was intrigued though by the mention of using Inertia.js\nwith Phoenix. I had heard of Inertia.js before, but I never really looked into\nit. So I decided to do a little digging and see what the differences were\nbetween the two.",[31,32,34],"h2",{"id":33},"what-is-inertiajs","What is Inertia.js?",[10,36,37],{},"Inertia.js is a framework-agnostic library that allows you to build modern\nsingle-page applications (SPAs) using server-side routing and controllers. It\nprovides a way to create SPAs without the need for a full-fledged JavaScript\nframework like React or Vue. Instead, you can use your existing server-side\nframework (like Laravel, Rails, or Phoenix) to handle routing and data fetching,\nwhile Inertia.js takes care of the client-side rendering. It was created with\nLaravel in mind, but it has official adapters for other frameworks as well,\nincluding Phoenix.",[10,39,40],{},"The idea behind Inertia.js is to provide a way to build SPAs that feel like\ntraditional server-rendered applications, while still taking advantage of the\nbenefits of client-side rendering. It allows you to use your existing\nserver-side framework to handle routing and data fetching, while still providing\na smooth and responsive user experience.",[31,42,44],{"id":43},"building-a-todo-app","Building a Todo app",[10,46,47,48,53,54,59],{},"In order to properly compare the two, I decided to build a simple Todo app using\nboth ",[14,49,52],{"href":50,"rel":51},"https://github.com/briancbarrow/phoenix_inertia_todo",[18],"Inertia.js"," and\n",[14,55,58],{"href":56,"rel":57},"https://github.com/briancbarrow/phoenix_liveview_todo",[18],"LiveView",". I wanted to\nsee how they compared in terms of ease of use, performance, and overall\ndeveloper experience. Getting a basic CRUD app running with LiveView is pretty\nstraightforward, especially using the Phoenix generators.",[10,61,62],{},"My goal in building the Inertia version was to get it to have a similar look and\nfeel as the LiveView version. This meant the form submission for creating and\nupdating todos would be handled inside of a modal. In my opinion, this is\nhandled very well in LiveView and you can easily create handler functions that\nwill properly validate the form and return any errors, setting them on the\nsocket.",[10,64,65],{},"When using Inertia, I really did like the idea of having the server handle\nthings like routing, data fetching and authentication. As I started to build the\napp with it, things did seem to go relatively smoothly. I was able to get the\nbasic CRUD functionality up and running and still be able to handle flash\nmessages. Getting the \"happy path\" working was fairly straightforward. The\nInertia adapter does also provide an easy to use function for assigning errors\nto the response. But that is where I started to run into some issues.",[10,67,68,69,73],{},"Although Inertia eventually ends up sending a JSON response back to the client,\nit does so by calling the ",[70,71,72],"code",{},"render_inertia"," function which takes in the name of\nthe component to render. It then passes the data to the component and renders\nit. Because my React component was the TodoList page that also had the modal in\nit, I then had to change the shape of my component to pass the appropriate data\nto the modal and make sure it statyed open. That meant my previous iteration of\nthe page component was no longer valid and I was changing how I was interacting\nwith my client side code to make it work. That isn't necessarily a bad thing,\nbut I did start to wonder if this was something I really wanted to do. The whole\npoint of using Inertia was to be able to use my existing knowledge of frontend\nframeworks and not need too much of a paradigm shift building the app. This felt\nlike I was having to change my approach to fit the library. If I am going to do\nthat, I felt like I might as well just embrace the LiveView way of doing things.",[10,75,76,77,82,83,88],{},"I will note that I was using React for the frontend, which is my least favorite\nfrontend framework. I don't have deep familiarity with it, so there is a chance\nthat this boils down to my own skill issues. The fact that there are whole other\nlibraries (see\n",[14,78,81],{"href":79,"rel":80},"https://inertiaui.com/inertia-modal/docs/introduction",[18],"inertia-modal",", as well\nas\n",[14,84,87],{"href":85,"rel":86},"https://laracasts.com/discuss/channels/inertia/inertiajs-to-open-a-route-in-a-modal-window-with-this-package",[18],"this comment thread listing some on Laracasts.com",")\nto make modals work better with Inertia does make me thing that this likely\nisn't just a me issue.",[31,90,92],{"id":91},"testing","Testing",[10,94,95,96,101,102,107],{},"I presented the two different approaches at the Utah Elixir Meetup this week,\nmostly highlighting the positives of Inertia. We often get glowing reviews of\nLiveView in the Elixir space, and I wanted to show that there are other options\nout there. During that presentation I did have a comment/question about the\ndifferences in testing between the two approaches. To be honest, I haven't done\na lot of testing with either approach, but I do know that LiveView has a lot of\nbuilt in testing functionality. Inertia does have some standard approaches to\ntesting that you would expect (end to end, client side unit testing) as well as\n",[14,97,100],{"href":98,"rel":99},"https://inertiajs.com/testing",[18],"endpoint testing",". The adapter for Phoenix does\nprovide some\n",[14,103,106],{"href":104,"rel":105},"https://github.com/inertiajs/inertia-phoenix?tab=readme-ov-file#testing",[18],"decent helpers for testing","\nas well.",[10,109,110],{},"Even with that being said, I do think that LiveView has a leg up on Inertia when\nit comes to testing. The fact that LiveView is built into the framework means\nthat it has a lot of built in functionality that makes testing easier. You can\neasily test the socket and the state of the LiveView, as well as the\ninteractions with the client side code. Inertia, on the other hand, is a\nthird-party library that is built on top of Phoenix. It does a great job of\nproviding a way to build SPAs, but because there is still a level of separation\nbetween the server and the client, I would need to bring in a separate testing\nlibrary to test the client side code. It is so incredibly nice to be able to\nwrite something like this to test a client side interaction with LiveView:",[112,113,118],"pre",{"className":114,"code":115,"language":116,"meta":117,"style":117},"language-elixir shiki shiki-themes github-dark","test \"saves new task\", %{conn: conn} do\n      {:ok, index_live, _html} = live(conn, ~p\"/tasks\")\n\nassert index_live |> element(\"a\", \"New Task\") |> render_click() =~\n               \"New Task\"\n\nassert_patch(index_live, ~p\"/tasks/new\")\n","elixir","",[70,119,120,128,134,141,147,153,158],{"__ignoreMap":117},[121,122,125],"span",{"class":123,"line":124},"line",1,[121,126,127],{},"test \"saves new task\", %{conn: conn} do\n",[121,129,131],{"class":123,"line":130},2,[121,132,133],{},"      {:ok, index_live, _html} = live(conn, ~p\"/tasks\")\n",[121,135,137],{"class":123,"line":136},3,[121,138,140],{"emptyLinePlaceholder":139},true,"\n",[121,142,144],{"class":123,"line":143},4,[121,145,146],{},"assert index_live |> element(\"a\", \"New Task\") |> render_click() =~\n",[121,148,150],{"class":123,"line":149},5,[121,151,152],{},"               \"New Task\"\n",[121,154,156],{"class":123,"line":155},6,[121,157,140],{"emptyLinePlaceholder":139},[121,159,161],{"class":123,"line":160},7,[121,162,163],{},"assert_patch(index_live, ~p\"/tasks/new\")\n",[10,165,166,167,170],{},"This is a pretty simple test that tests the rendering of the 'tasks' page and\nthen tests that the correct request is made when the user clicks the \"New Task\"\nbutton. Not to mention that this test is auto generated when using the\n",[70,168,169],{},"phx.gen.live"," generator. If/when you end up changing the way the page works and\nis laid out from what the generator creates, you can still use the generated\ntest as a starting point and still have access to testing the client side code.\nThat is a huge win for LiveView in my opinion.",[31,172,174],{"id":173},"conclusion","Conclusion",[10,176,177],{},"I was pretty excited to try out Inertia.js. I had heard a lot of good things\nabout it, and honestly a lot of the praise for it is well deserved. If you are\ncoming from a traditional SPA background, it is a great way to build SPAs if you\nare fine with needing multiple testing libraries for each side of the app.",[10,179,180],{},"If I was to build a project using a different backend language, I would\ndefinitely consider using Inertia.js.",[10,182,183],{},"For me though, I think I will stick with LiveView for now, at least when working\nwith Phoenix.",[185,186,187],"style",{},"html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"title":117,"searchDepth":130,"depth":130,"links":189},[190,191,192,193],{"id":33,"depth":130,"text":34},{"id":43,"depth":130,"text":44},{"id":91,"depth":130,"text":92},{"id":173,"depth":130,"text":174},"2025-04-26T00:00:00.000Z","A comparison of Inertia.js and LiveView for building modern web applications.","md","inertia-vs-liveview/header.jpg",{"alt":199},"The Inertia.js and LiveView logos","/blog/inertia-vs-liveview",{"title":5,"description":195},"blog/inertia-vs-liveview",null,"NkpP1m38ZykPC-ICh6dkMCAhR9z0AUdnw5F_LbS3gVk",1750540913837]